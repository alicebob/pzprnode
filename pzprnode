#!/usr/bin/env node

const http = require('http');
const child_process = require('child_process');
const url = require('url');
const fs = require('fs');
const querystring = require('querystring');

const pzpr = require('pzpr');

const templates = process.env.TEMPLATES_DIR || './templates';
const pzprdir = process.env.PZPR_DIR || '.';

const hostname = '127.0.0.1';
const port = 3456;

function preview(req, res, query) {
	if (!query) {
		res.statusCode = 400;
		res.end();
		return;
	}
	// querystring parse replaces unencoded '+' by ' ',
	// but pzprjs wants the literal '+'
	query = query.replace(/\+/g, '%2B');
	const q = querystring.parse(query);
	var thumb = false;
	var pzv = '';
	for (var key in q) {
		if (key === 'thumb') {
			thumb = true;
		} else if (pzv === '' && q[key] === '') {
			pzv = key;
		}
	}
	if (!pzv) {
		res.statusCode = 400;
		res.end();
		return;
	}

	const canvas = {};
	const p = new pzpr.Puzzle(canvas);
	p.open(pzv, () => {
		p.setMode('play');
		p.setConfig('undefcell', false);
		p.setConfig('autocmp', false);
		const svg = p.toBuffer('svg', 0, 30);
		res.statusCode = 200;
		res.setHeader('Content-Type', 'image/png');

		var out = res;

		if (thumb) {
			const args = ['convert', 'PNG:-', '-resize', '200x200', 'PNG:-'];
			const resize = child_process.spawn('gm', args);
			out = resize.stdin;
			resize.on('error', (err) => {
				console.log('error starting gm:', err);
			});
			resize.on('close', (code) => {
				if (code !== 0) {
					console.log('gm exited with error');
				}
				res.end();
			});
			resize.stderr.on('data', (data) => {
				console.log(data.toString());
			});
			resize.stdout.on('data', (data) => {
				res.write(data);
			});
		}

		const convert = child_process.spawn('rsvg-convert');
		convert.on('error', (err) => {
			console.log('error starting rsvg-convert:', err);
		});
		convert.on('close', (code) => {
			if (code !== 0) {
				console.log('rsvg-convert exited with error');
			}
			out.end();
		});
		convert.stderr.on('data', (data) => {
			console.log(data.toString());
		});
		convert.stdout.on('data', (data) => {
			out.write(data);
		});
		convert.stdin.end(svg);
	});
}

function processPost(req, res, callback) {
	var queryData = "";
	if(typeof callback !== 'function') { return null; }

	req.on('data', function(data) {
		queryData += data;
		if (queryData.length > 1024) {
			queryData = ""
			res.writeHead(413, {'Content-Type': 'text/plain'}).end();
			req.connection.detroy();
		}
	});

	req.on('end', function() {
		req.post = querystring.parse(queryData);
		callback();
	});
}

const rawpage = fs.readFileSync(pzprdir + '/p.html', 'utf8');
const parts = rawpage.split(/<title>[^<]*<\/title>/i);
const head = parts[0];
const body = parts[1];
const metatmpl = fs.readFileSync(templates + '/meta.template', 'utf8');
const callbacktmpl = fs.readFileSync(templates + '/callback.template', 'utf8');
const callbackanontmpl = fs.readFileSync(templates + '/callback-anon.template', 'utf8');

function substitute(tmpl, vars) {
	for (var key in vars) {
		tmpl = tmpl.replace(new RegExp('%%' + key + '%%', 'g'), vars[key]);
	}
	return tmpl;
}

function sendPage(res, pzv, user_id, token) {
	if (!pzv) {
		res.end(rawpage);
	}
	const p = new pzpr.Puzzle();
	try {
		p.open(pzv, () => {
			var title = p.info.en;
			var size = "";
			if (!isNaN(p.board.cols) && !isNaN(p.board.rows)) {
				size = "" + p.board.rows + "Ã—" + p.board.cols;
			}
			var desc = 'Solve a ' + p.info.en + ' puzzle';
			if (size) {
				title = size + ' ' + title;
				desc += ', size ' + size;
			}
			desc += '.';
			var vars = {
				'CANONICAL_URL': 'https://puzz.link/p?' + pzv,
				'TITLE': title,
				'DESCRIPTION': desc,
				'PREVIEW_IMG': 'https://puzz.link/pv?' + pzv,
				'PZV': pzv,
				'TOKEN': token,
				'USER_ID': user_id
			};
			res.statusCode = 200;
			res.setHeader('Content-Type', 'text/html');
			res.write(head);
			res.write(substitute(metatmpl, vars));
			if (user_id && token) {
				res.write(substitute(callbacktmpl, vars));
			} else {
				res.write(substitute(callbackanontmpl, vars));
			}
			res.end(body);
		});
	} catch(error) {
		console.log('caught error', error, 'sending raw page');
		res.end(rawpage);
	}
}

const server = http.createServer((req, res) => {
	// TODO: this try block doesn't seem to catch exceptions from the
	// post handler
	try {
		console.log('handling request:', req.url);
		const u = url.parse(req.url);
		switch (u.pathname) {
		case '/pv':
			preview(req, res, u.query);
			break;
		case '/p':
			if (req.method == 'POST') {
				processPost(req, res, function() {
					sendPage(res, u.query, req.post.user_id, req.post.token);
				});
			} else {
				sendPage(res, u.query, "", "");
			}
			break;
		default:
			console.log('404', u.pathname);
			res.statusCode = 404;
			res.end();
			break;
		}
	} catch (error) {
		console.log("caught error:", error);
		res.statusCode = 500;
		res.end();
	}
});

server.listen(port, hostname, () => {
	console.log(`Server running at http://${hostname}:${port}/`);
});

